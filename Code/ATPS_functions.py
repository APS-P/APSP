# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hg1E21ppVMNk6FJFcasdGxOpo9_C-LOj
"""

import sys
import time
import Bio
from Bio import Entrez
from Bio.Seq import Seq
from subprocess import Popen, PIPE
import subprocess
import threading
import pexpect
import os
from Bio.Phylo.PAML import codeml
from Bio import AlignIO
from Bio import Phylo
from Bio.Phylo.Applications import PhymlCommandline
from Bio.Phylo.TreeConstruction import DistanceCalculator
from Bio.Phylo.TreeConstruction import DistanceCalculator, DistanceTreeConstructor
import subprocess
import os.path
import os
import sys
import shutil
import pandas as pd
from scipy.stats import chi2
import urllib.request
import glob
import openpyxl
import matplotlib.pyplot as plt
import os, io, random
import string
import numpy as np
from bokeh.plotting import figure, output_file, show
from Bio.Seq import Seq
from Bio.Align import MultipleSeqAlignment
from Bio import AlignIO, SeqIO
import mne
import numpy as np
import panel as pn
import panel.widgets as pnw
pn.extension()

from bokeh.plotting import figure
from bokeh.models import ColumnDataSource, Plot, Grid, Range1d
from bokeh.models.glyphs import Text, Rect
from bokeh.layouts import gridplot
##
##
##n = len(sys.argv)
##taxonomy = sys.argv[1]
##protein  = sys.argv[2]
#print (taxonomy, protein)



def fetchingbyspecies(protein,List_species,interest, fetch, gene_path, inp_file):
    protein_dict = {}
    if fetch == 1:
        Entrez.email = "mirocc3@gmail.com"
        if not Entrez.email:
            print ("you must add your email address")
            sys.exit(2)
        species_list = []
        seq_dict = {}
        filter_gene = "[gene=" + protein + "]"
        for i in List_species:
            Searched_Term = "{}[Organism] OR {}[All Fields] AND {}[Title] AND (biomol_mrna[PROP] AND refseq[filter])".format(i, i, protein)
            handle = Entrez.esearch(db="nuccore", term = Searched_Term, retmax = 4000, usehistory="y", idtype="acc")
            search_results = Entrez.read(handle)
            acc_list = search_results["IdList"]
            count = int(search_results["Count"])
            #print(count)
            webenv = search_results["WebEnv"]
            query_key = search_results["QueryKey"]
            begin = 0
            indiced_list = []
            fetch_handle = Entrez.efetch(db="nuccore",
                                             rettype="fasta_cds_na",
                                             retmode="text",
                                             retmax=count,
                                             webenv=webenv,
                                             query_key=query_key,
                                             idtype="acc")
            data = fetch_handle.read()
            fetch_handle.close()
            for data1 in str(data).split('\n\n')[:-1]:
                sequence = ''
                accession_num = ''
                if  filter_gene.lower() in data1.lower():
                    for x in range(len(data1)):
                        if data1[x] == '|':
                            begin = 1
                            continue
                        elif data1[x] == '.':
                            accession_num += data1[x] + data1[x+1]
                            begin = 0
                            break
                        if begin == 1:
                            accession_num += data1[x]
                    sequence = data1[data1.find(']\n')+1:]
                    indiced_list.append(sequence)
            if indiced_list:
                seq_npartial = Seq(max(indiced_list, key = len).replace("\n", "").strip())
            else:
                print("there is nos sequences for this species : " + i)
                continue
            if (not "*" in str(seq_npartial.translate())[0:-1]) and (str(seq_npartial).startswith("ATG")) and str(seq_npartial.translate()).endswith('*'):
                seq_dict[i] = max(indiced_list, key = len)
            else:
                seq_dict[i] = ''
                for j in range(len(indiced_list)):
                    seqs_npartial = Seq(indiced_list[j].replace("\n", '').strip())
                    if len(indiced_list[j]) > len(seq_dict[i]) and not '*' in str(seqs_npartial.translate())[0:-1] and (str(seqs_npartial).startswith("ATG")) and str(seqs_npartial.translate()).endswith("*"):
                        seq_dict[i] = indiced_list[j]
                if seq_dict[i] == '':
                    if i == interest:
                        print(interest," not found the default is used instead")
                        carry = list_species.copy()
                        carry.remove(i)
                        interest = carry[0]
                    seq_dict.pop(i, None)
    else:
        gene_open = open(gene_path + "/" + inp_file, 'r')
        gene_instance = gene_open.read()
        ## to be changed
        if not "\n\nA" in gene_instance or not "\n\n>" in gene_instance:
             addlines(str(gene_path) + "/" + inp_file, "CodingSequences.fasta")
        coding_seqopen = open("CodingSequences.fasta")
        seq_instances = coding_seqopen.read()
        seq_lisinst = seq_instances.split("\n\n")
        seq_lisinst = list(filter(('').__ne__, seq_lisinst))
        seq_dict = zip((seq_lisinst[r].replace('\n', '').replace('>', '') for r in range(0,len(seq_lisinst),2)),( seq_lisinst[r] for r in range(1,len(seq_lisinst),2)))
        seq_dict = dict(seq_dict)
    out_handle = open("CodingSequences.fasta", "w")
    out_handle_prot = open("ProteinSequences.fasta", "w")
    for specie in seq_dict.keys():
        to_trans = Seq(seq_dict[specie].replace("\n", "").strip())
        protein_dict[specie] = str(to_trans.translate())
    keysList = list(seq_dict.keys())
    print(keysList)
    valueList = list(seq_dict.values())
    redacted = ''
    for i, j in zip(keysList, valueList):
        if ' ' in i:
            i = i.replace(' ','_')
        if fetch == 0:
            redacted += '>' + i + '\n\n'
        else:
            redacted += '>' + i + '\n\n'
        redacted += j + '\n\n'
    out_handle.write(redacted)
    out_handle.close()
    keysList = list(protein_dict.keys())
    valueList = list(protein_dict.values())
    redacted = ''
    n = 60

    for i, j in zip(keysList, valueList):
        if ' ' in i:
            i = i.replace(' ','_')
        redacted += '>' + i + '\n'
        lst = [j[i:i+n] for i in range(0, len(j), n)]
        redacted += '\n'.join(lst) + '\n'
    out_handle_prot.write(redacted)
    out_handle_prot.close()
    if valueList:
        list_empty = True
    else:
        list_empty = False
    return list_empty, interest


# imported libraries below
# This is incomplete, we need to add f'' string
file_path = "ProteinSequences.fasta"
def diff_aligners(file_path , align_type):
    
    if align_type == "mu":
        try:
            subprocess.run('(muscle -in ' + file_path + ' -out Alignment.ali)', shell=True, check=True)
        except:
            os.system("sudo apt install muscle")
            subprocess.run('(muscle -in ' + file_path + ' -out Alignment.ali)', shell=True, check=True)

    elif align_type == "cl":
        print('Running Clustalo. Please wait till it finishes...')
        subprocess.run('(clustalo -i ' + file_path + ' -o Alignment.ali)', shell=True, check=True)
        print('Process completed...')
    elif align_type == "mf":
        subprocess.run('(mafft ' + file_path + ' > Alignment.ali)', shell=True, check=True)
    else:
        print('The program will now exit.')


def addlines(target_file, out_file):
    redact_protein = open(out_file , "w")
    protein_file = open(target_file, "r")
    m = protein_file.readlines()
    for i in m:
        if ">" in i:
            redact_protein.write("\n")
            redact_protein.writelines(i)
            redact_protein.write("\n")
            continue
        redact_protein.writelines(i)



"""
    code for reverse translation
"""
def reversedd(interest):
    org_listseqsplt = []
    species_sorted = []
    transeq = []
    org_seq = open("CodingSequences.fasta", "r") ##open original sequences file
    ali_prot = open("Sequences_Alignment.ali","r") ## open protein alignment file
    fasta = open("Reverse_Translation_Seq.txt" , "w") ## open file to write the coding sequences with gaps
    org_sequences = org_seq.read() ## reading original sequences file
    ali_protein = ali_prot.read() ## reading protein alignment file
    org_listseq = org_sequences.split("\n\n") ## splitting the sequences at each \n\n
    ali_listprot = ali_protein.split("\n\n") ## splitting the protein file at eacg \n\n
    org_listseqnt = [org_listseq[i].replace("\n", '') for i in range(1,len(org_listseq),2)] ## sequences without titles
    species_seq = [org_listseq[i].replace("\n", '') for i in range(0,len(org_listseq),2)]
    species_prot = [ali_listprot[i].replace("\n", '') for i in range(0,len(ali_listprot),2)]
    ali_listprotnt = [ali_listprot[i].replace("\n", '') for i in range(1,len(ali_listprot),2)] ## sequences without titles
    #print(species_prot , species_seq)
    for j in org_listseqnt:
        org_listseqsplt.append([j[i:i+3] for i in range(0, len(j), 3)])
    gapped_seq = []
    prot_dict = dict(zip(species_prot,ali_listprotnt))
    seq_dict = dict(zip(species_seq,org_listseqsplt))
    print(prot_dict)
    print(seq_dict)
    full_dict = {}
    for i in prot_dict.keys():
        #print(full_dict)
        full_dict[i] = (prot_dict[i], seq_dict[i])
        species_sorted.append(i)
    seq_sort = [full_dict[i][1] for i in full_dict.keys()]
    prot_sort = [full_dict[i][0] for i in full_dict.keys()]
    count = 0
    for i in range(len(prot_sort)):
        codon = 0
        count += 1
        if species_sorted[i] == ('>' + interest):
            transeq.insert(0, species_sorted[i])
        else:
            transeq.append(species_sorted[i])
        for j in prot_sort[i]:
            if j == '-':
                gapped_seq.append("---")
            else:
                gapped_seq.append(seq_sort[i][codon])
                codon += 1
        if species_sorted[i] == ('>' + interest):
            transeq.insert(1, ''.join(gapped_seq))
        else:
            transeq.append(''.join(gapped_seq))
        gapped_seq = []
    #print(transeq)
    fasta.write('\n\n'.join(transeq))
    fasta.close()
    return

def Gblocks():
    os.system('Gblocks_0.91b/Gblocks Reverse_Translation_Seq.txt -t=c -e=-gb1 -b5=h -d=y -b2=0')

def convert_fst_phy():
    os.system("java -jar jmodeltest-2.1.7/jModelTest.jar -d Reverse_Translation_Seq.txt-gb1 -getPhylip")

def rem_spaces():
    f = open("Reverse_Translation_Seq.txt-gb1" , "r")
    m = open("Reverse_Translation_Seq.txt-gb1.fst" , "a") #this file include the data in  Reverse_Translation_Seq.txt-gb1 without internal gaps.
    for  i in f.read():
        if i != " ":
            m.writelines(i)
        if i == " ":
            continue
def jmodel():
    os.system("java -jar jmodeltest-2.1.7/jModelTest.jar -d Reverse_Translation_Seq.txt-gb1.phy -s 11 -g 4 -t BIONJ -f -i -AICc -o Jmodeltest_output")


def parsing_jmodeltest():
    lis = []
    filt = []
    flag = 0
    freq = ''
    partition = ''
    pinvar = ''
    with open("Jmodeltest_output","rb") as f: lis.extend(f.readlines())
    for i in lis:
        if 'Model selected:' in str(i):
            flag = 1
        if 'partition = ' in str(i):
            partition = str(i).replace("b'   partition = ", '').strip('\n').replace("'",'')[:6]
        if 'p-inv = ' in str(i):
            pinvar = str(i).replace("b'   p-inv = ", '').strip('\n').replace("'",'')[:6]
        if flag == 1:
            filt.append(str(i))
        if 'Tree ' in str(i):
            flag = 0
    for i in filt:
        if 'freqA' in str(i):
            freq += str(i).replace("b'   freqA = ", '').strip('\n').replace("'",'')[:6]
            freq += ','
        if 'freqC' in str(i):
            freq += str(i).replace("b'   freqC = ", '').strip('\n').replace("'",'')[:6]
            freq += ','
        if 'freqG' in str(i):
            freq += str(i).replace("b'   freqG = ", '').strip('\n').replace("'",'')[:6]
            freq += ','
        if 'freqT' in str(i):
            freq += str(i).replace("b'   freqT = ", '').strip('\n').replace("'",'')[:6]
    return partition, freq, pinvar

def spare_parse():
    open_ = open("Jmodeltest_output" , "r")
    read_ = open_.read()
    names = []
    freq = ""
    jmodel_out = []
    list_name = []
    start_name = read_.find("cumWeight\n-")
    stop_name = read_.find("-\n-lnL")
    list_name = read_[start_name + 85 :stop_name - 84]
    list_name1 = [line[:line.index(" ")] for line in list_name.split("\n")]
    for i in list_name1[1:]:
        start_model = read_.find("   Model = " + i)
        stop_model = read_[start_model:].find("\n \n")
        model_list = read_[start_model:start_model + stop_model]
        if "freqA = " not in model_list:
            continue
        else:
            for i in model_list.split("\n"):
                if "partition =" in i:
                    partition = str(i).replace("   partition = ", '').strip('\n').replace("'",'')[:6]
                if 'p-inv = ' in str(i):
                    pinvar = str(i).replace("   p-inv = ", '').strip('\n').replace("'",'')[:6]
                if 'freqA' in str(i):
                    freq += str(i).replace("   freqA = ", '').strip('\n').replace("'",'')[:6]
                    freq += ','
                if 'freqC' in str(i):
                    freq += str(i).replace("   freqC = ", '').strip('\n').replace("'",'')[:6]
                    freq += ','
                if 'freqG' in str(i):
                    freq += str(i).replace("   freqG = ", '').strip('\n').replace("'",'')[:6]
                    freq += ','
                if 'freqT' in str(i):
                    freq += str(i).replace("   freqT = ", '').strip('\n').replace("'",'')[:6]
            break
    return partition, freq, pinvar

def phyml(partition, freq, pinvar):
    os.system("phyml -i Reverse_Translation_Seq.txt-gb1.phy -d nt -b 100 -f e -m " + partition + ' -f ' + freq + " -v " + pinvar )
    os.rename("Reverse_Translation_Seq.txt-gb1.phy_phyml_boot_trees.txt", "Species_Phylogenetic_boot_trees.txt")
    os.rename("Reverse_Translation_Seq.txt-gb1.phy_phyml_tree.txt", "Species_Phylogenetic_tree.txt")
    os.rename("Reverse_Translation_Seq.txt-gb1.phy_phyml_stats.txt", "Species_Phylogenetic_stats.txt")
    os.rename("Reverse_Translation_Seq.txt-gb1.phy_phyml_boot_stats.txt", "Species_Phylogenetic_boot_stats.txt")
    #os.rename("Reverse_Translation_Seq.txt-gb1.phy", "")    
    
    
def convert_to_newickTree():
    aln = AlignIO.read('Reverse_Translation_Seq.txt-gb1.phy', 'phylip-relaxed')
    t = Phylo.read("Species_Phylogenetic_tree.txt", "newick")
    scorer = Phylo.TreeConstruction.ParsimonyScorer()
    searcher = Phylo.TreeConstruction.NNITreeSearcher(scorer)
    constructor = Phylo.TreeConstruction.ParsimonyTreeConstructor(searcher, t)
    pars_tree = constructor.build_tree(aln)
    Phylo.write(pars_tree, "Species_Phylogenetic_tree_phyloxl.xml", "phyloxml")
    Phylo.convert("Species_Phylogenetic_tree_phyloxl.xml", "phyloxml", "Species_Phylogenetic_tree_newick.nwk", "newick")

def parsing_treefile():
    liss = []
    with open("Species_Phylogenetic_tree_newick.nwk","rb") as m: liss.extend(str(m.readlines()))
    trim = ''.join(liss)
    results = ''.join([i for i in trim if not i.isdigit() and i != ':' and i != '.' and i != "\n"])[3:-4]
    y = open("Species_Phylogenetic_tree_newick_nodistances.nwk","w")
    y.writelines(results)

#sys.exit(0)

def model078():
    f = open("codeml.ctl", "w")
    m = open("codeml078.ctl" , "r")
    f.writelines(m)
    f.close()
    os.system("codeml")

def BEB(path):

    codeml078 = open(path + "/" + "codeml078/codeml078_mlc.txt", "r")
    BEB_read = codeml078.read()
    start = BEB_read.find("Bayes Empirical Bayes (BEB)") ## getting 
    end = BEB_read.find("the grid") ## getting
    BEB_list = []
    BEB_list = BEB_read[start : end].split("\n\n")[2].replace("         ", ",").replace("*        ", ",").replace("      ", ",").replace("*       ", "**,")

    BEB_list = '\n'.join([','.join([line.strip().replace(" ", ",").split(",", 3)[n] for n in range(3)]) for line in BEB_list.split('\n')])

    return BEB_list


def Positive_selection_sites(BEB_list, interest, path):
    original = path + "/" +"Reverse_Translation_Seq.txt-gb1.htm"
    target = path + "/" +"Reverse_Translation_Seq.txt-gb1.txt"
    shutil.copyfile(original , target)
    gblocks_file = open(path + "/" + "Reverse_Translation_Seq.txt-gb1.txt" , "r")

    Positive_selection_sites = []
    BEB = ''
    counter = 0
    for b in BEB_list:
        BEB += b
    BEB_position = BEB.replace("\n" , ",").split(",")[::3]

    BEB_positions = [int(BEB_position[i+1]) - int(BEB_position[i]) for i in range(len(BEB_position)-1)]

    BEB_positions.insert(0,int(BEB_position[0]))

    g_postiotns = [i.replace("Flanks: " , "").replace("\n","").replace("[" , "").replace("]" , "").replace("  ", " ").strip().split(" ") for i in gblocks_file.readlines() if "Flanks: " in i]

    posi_listt = g_postiotns[0]
    posi_listt = [int(i)//3 for i in posi_listt]

    posi_list = [[posi_listt[i],posi_listt[i+1]] for i in range(0,len(posi_listt)-1,2)]

    carrier = [i[1] - i[0] for i in posi_list]

    for i in BEB_positions:
        while carrier[0] != 0:
            if i < carrier[0]:
                posi_list[0][0] += i
                Positive_selection_sites.append(posi_list[0][0])
                carrier[0] -= i
                break
            elif i == carrier[0]:
                Positive_selection_sites.append(posi_list[0][1])
                posi_list.pop(0)
                carrier.pop(0)
                break
            else:
                i -= carrier[0]
                carrier.pop(0)
                posi_list.pop(0)

    ps_list = []
    j = 0
    for i in BEB_list.split("\n"):
        ps_list.append(str(i) + ',' + str(Positive_selection_sites[j]))

        j += 1
    ps_list = '\n'.join(ps_list)
    BEB_csv = open(path + "/" + "BEB.csv", "w")
    BEB_csv.write(ps_list)
    return Positive_selection_sites


def model8a():
    f = open("codeml.ctl", "w")
    m = open("codeml8a.ctl" , "r")
    f.writelines(m)
    f.close()
    os.system("codeml")

#sys.exit(0)

def hashing(interest):  
    newick_open = open("Species_Phylogenetic_tree_newick_nodistances.nwk")
    newick_create = open("Species_Phylogenetic_tree_newick_Interst#.nwk", 'w')
    #interest_open = open("interest.txt")
    #interest =r interest_open.read()
    newick_read = newick_open.read()
    newick_list = newick_read.split(',')
    result = newick_read.find(str(interest))
    print(result)
    result += len(interest)
    print(result)
    newick_read = newick_read[:result] + " #1" + newick_read[result:]
    newick_open.close()
    print(newick_read)
    newick_create.write(newick_read)

def model2a():
    f = open("codeml.ctl", "w")
    m = open("codeml2a.ctl" , "r")
    f.writelines(m)
    f.close()
    os.system("codeml")

#sys.exit(0)
def model2():
    f = open("codeml.ctl", "w")
    m = open("codeml2.ctl" , "r")
    f.writelines(m)
    f.close()
    os.system("codeml")

#sys.exit(0)

def codeml_output(inp, protein):
    modelsnum1 = []
    modelsnum2 = ''
    num2 = ''
    codeml_lines = []
    #protein = "TP53"
    reader1 = open("codeml078/codeml078_mlc.txt","r")
    strcml1 = str(reader1.read())
    #needs refactoring (optimization)
    def parse(model):
        num1 = ''
        flag = 0
        flag2 = 0
        for i in range(len(model)):
            if model[i] == 'l' and model[i+1] == 'n' and model[i+2] == 'L':
                flag = 1
            if flag == 1:
                if model[i] == '-':
                    flag2 = 1
                elif model[i] == ' ' and flag2 == 1:
                    num1 += ' '
                    flag2 = 0
                    flag = 0
            if flag2 == 1:
                num1 += model[i]
        return num1
    modelsnum1 = parse(strcml1).split(' ')[:-1]
    print(modelsnum1)
    for i in range(len(modelsnum1)):
        x = modelsnum1[i]
        modelsnum1[i] = [float(x)]
        modelsnum2 += str(float(x))
        modelsnum2 += ','
    print(modelsnum1)
    reader2 = open("codeml8a/codeml8a_mlc.txt","r")
    strcml2 = str(reader2.read())
    print(parse(strcml2))
    modelsnum1.append([float(parse(strcml2))])
    print(modelsnum1)
    modelsnum2 += str(float(parse(strcml2)))
    modelsnum2 += ','
    if inp == 1:
        reader3 = open("codeml2a/codeml2a_mlc.txt","r")
        strcml3 = str(reader3.read())
        print(parse(strcml3))
        modelsnum1.append([float(parse(strcml3))])
        modelsnum2 += str(float(parse(strcml3)))
        modelsnum2 += ','
        print(modelsnum1)
        reader4 = open("codeml2/codeml2_mlc.txt","r")
        strcml4 = str(reader4.read())
        print(parse(strcml3))
        modelsnum1.append([float(parse(strcml4))])
        modelsnum2 += str(float(parse(strcml4)))
        modelsnum2 += ','
        print(modelsnum1)
        lrt22a = 2*(modelsnum1[4][0] - modelsnum1[5][0])
    else:
        modelsnum1.append([''])
        modelsnum2 += ','
        modelsnum1.append([''])
        modelsnum2 += ','
        lrt22a = ''

    lrt78 = 2*(modelsnum1[2][0] - modelsnum1[1][0])
    lrt88a = 2*(modelsnum1[2][0] - modelsnum1[3][0])

    modelsnum1.append([lrt78])
    modelsnum2 += str(lrt78)
    modelsnum2 += ','
    modelsnum1.append([lrt88a])
    modelsnum2 += str(lrt88a)
    modelsnum2 += ','
    modelsnum1.append([lrt22a]) 
    modelsnum2 += str(lrt22a)
    modelsnum2 += ','

    chi1 =  1 - chi2.cdf(lrt78, 2)
    chi22 =  1 - chi2.cdf(lrt88a, 1)
    if inp == 1:
        chi3 =  1 - chi2.cdf(lrt22a, 1)
    else: chi3 = ''
    modelsnum1.append([chi1])
    modelsnum2 += str(chi1)
    modelsnum2 += ','
    modelsnum1.append([chi22])
    modelsnum2 += str(chi22)
    modelsnum2 += ','
    modelsnum1.append([chi3])
    modelsnum2 += str(chi3)
    modelsnum2 += ','
    
    model = ["Name","Model0", "Model7", "Model8","Model8a", "Model2a", "Model2", "LRT(M7_vs_M8)", "LRT(M8a_vs_M8)", "LRT(M2a_vs_M2)", "p-v7vs8", "p-v8avs8", "p-v2avs2"]

    modelsnum1.insert(0,[protein])
    modelsnum2 = protein + ',' + modelsnum2
    dictt = dict(zip(model, modelsnum1))
    df = pd.DataFrame(dictt)
    df.to_csv('Gene_Output.csv')
    return modelsnum1, modelsnum2

def download():
    path = os.getcwd()
    list_files = glob.glob(path + "/*")
    if path + "/jmodeltest-2.1.7.tar.gz" not in list_files:
        os.system('wget "https://drive.google.com/uc?export=download&id=13cViInzCoaxrgHwmiWq3fXmStt4wwydJ" -O jmodeltest-2.1.7.tar.gz')
        os.system("tar -xf jmodeltest-2.1.7.tar.gz -C " + path)
    if path + "/Gblocks_Linux64_0.91b.tar.Z" not in list_files:
        os.system('wget "https://drive.google.com/uc?export=download&id=1syZCAT748J8_1BOyLOtuRgHXdRK54J2k" -O Gblocks_Linux64_0.91b.tar.Z')
        os.system("tar -xf Gblocks_Linux64_0.91b.tar.Z -C " + path)

 
     
def saving_(gene_name):
    path = os.getcwd()
    new_dir = path + "/" + gene_name + ".gene"
    print(new_dir)
    file_list = glob.glob(path + "/*")
    file_list.remove(path + "/ATPS.py")
    file_list.remove(path + "/importt.py")
    file_list.remove(path + "/ATPS_functions.py")
    file_list.remove(path + "/Study_Output.csv")
    try:
        os.system("mkdir " + new_dir)
    except OSError:
        print ("Creation of the directory %s failed" % path)
    else:
        print ("Successfully created the directory %s " % path)
    
    for i in file_list:
        print(i)
        try:
            shutil.copy(i , new_dir, follow_symlinks=True)
        except:
            os.system("cp -R " + i + " " + new_dir)
        
def deletion_files():
    try:
        os.remove("Alignment.ali")
    except:
        pass
    try:
        os.remove("BEB.csv")
    except:
        pass
    try:
        os.remove("Sequences_Alignment.ali")
    except:
        pass
    try:
        os.remove("codeml.ctl")
    except:
        pass
    try:
        os.remove("CodingSequences.fasta")
    except:
        pass
    try:
        os.remove("Species_Phylogenetic_tree_newick_nodistances.nwk")
    except:
        pass
    try:
        os.remove("Reverse_Translation_Seq.txt-gb1.fst")
    except:
        pass
    try:
        os.remove("Reverse_Translation_Seq.txt")
    except:
        pass
    try:
        os.remove("Reverse_Translation_Seq.txt-gb1")
    except:
        pass
    try:
        os.remove("Reverse_Translation_Seq.txt-gb1.htm")
    except:
        pass
    try:
        os.remove("Reverse_Translation_Seq.txt-gb1.phy")
    except:
        pass
    try:
        os.remove("Species_Phylogenetic_boot_stats.txt")
    except:
        pass
    try:
        os.remove("Species_Phylogenetic_boot_trees.txt")
    except:
        pass
    try:
        os.remove("Species_Phylogenetic_stats.txt")
    except:
        pass
    try:
        os.remove("Species_Phylogenetic_tree.txt")
    except:
        pass
    try:
        os.remove("Reverse_Translation_Seq.txt-gb1PS")
    except:
        pass
    try:
        os.remove("Species_Phylogenetic_tree_newick.nwk")
    except:
        pass
    try:
        os.remove("Species_Phylogenetic_tree_phyloxl.xml")
    except:
        pass
    try:
        os.remove("interest.txt")
    except:
        pass
    try:
        os.remove("Jmodeltest_output")
    except:
        pass
    try:
        os.remove("ProteinSequences.fasta")
    except:
        pass
    try:
        os.remove("Species_Phylogenetic_tree_newick_nodistances.nwk")
    except:
        pass
    try:
        os.remove("Species_Phylogenetic_tree.nwk")
    except:
        pass
    try:
        os.remove("Reverse_Translation_Seq.txt-gb1.txt")
    except:
        pass
    try:
        os.remove("phast_output.xlsx")
    except:
        pass
    try:
        os.remove("phyloFit.txt")
    except:
        pass
    try:
        del_paths = glob.glob(os.path.join(path,'*.mod'))
        for del_path in del_paths:
            os.remove(del_path)
    except:
        pass
    try:
        os.remove("wigscore")
    except:
        pass
    try:
        os.remove("wigscore.png")
    except:
        pass
    try:
        os.remove("positive_selection_sites.txt")
    except:
        pass



def del_codeml_dir():
    shutil.rmtree("codeml2")
    shutil.rmtree("codeml2a")
    shutil.rmtree("codeml8a")
    shutil.rmtree("codeml078")
    
def creat_codeml_dir():
    try:
        os.mkdir("codeml2")
    except:
        pass
    try:
        os.mkdir("codeml2a")
    except:
        pass
    try:    
        os.mkdir("codeml8a")
    except:
        pass
    try:    
        os.mkdir("codeml078")
    except:
        pass
def path_dir():
    path = os.getcwd()
    return path

def phast(gene):
    original = r"Species_Phylogenetic_tree.txt"
    target = r"Species_Phylogenetic_tree.nwk"
    shutil.copyfile(original , target)
    try:
        os.system("phyloFit --tree Species_Phylogenetic_tree.nwk Alignment.ali > "+gene+".mod")
    except:
        os.system("sudo apt-get install -y phast")
        os.system("phyloFit --tree Species_Phylogenetic_tree.nwk Alignment.ali > " + gene + ".mod")
    try:
       
        shutil.move('phyloFit.mod', 'phyloFit.txt')
    except:
        os.system("sudo apt-get install -y phast")
        os.system("phyloFit --tree Species_Phylogenetic_tree.nwk Alignment.ali > " + gene + ".mod")
        shutil.move('phyloFit.mod', 'phyloFit.txt')
        
    os.system("phyloP --wig-scores --method LRT --mode CONACC phyloFit.txt Alignment.ali > wigscore")
    file1 = open("wigscore","r")
    df = pd.read_table('wigscore')
    df.to_excel('phast_output.xlsx', 'Sheet1')
    #df['fixed'] = df['fixed'].str.replace(r'\D', '').astype(float)
    df.columns.values[0] = "Name"
    df=df[df.Name.str.contains(r'[.]')]
    print(df.head())
    df.head()
    df=df.astype(float)
    plt.style.use('seaborn-whitegrid')
    df=df.astype(float)
    p=df.plot.line(color="#0e6655")
    fig1 = plt.gcf()
    p.set_facecolor('#d0d3d4')
    #plt.draw()
    #try:
    #    plt.show()
    #except:
    #    plt.show()
    #else:
    fig1.savefig('wigscore.png', dpi=100)
        
        
def visualization_tree(interest):
    #%matplotlib inline

    tree = Phylo.read("Species_Phylogenetic_tree.txt", "newick")
    #print(tree)
    Phylo.draw_ascii(tree)
    tree.rooted = True

   # tree = tree.as_phyloxml()
    #tree = Phylogeny.from_tree(tree)
    #tree.root.color = "blue"           
    interest = str(interest)
    mrca = tree.common_ancestor({"name": interest}) #write the species under interest
    mrca.color = "salmon" #color species under interest


    #Phylo.draw(tree) #draw tree after colors   
    
def get_colors(seqs):
    """make colors for bases in sequence"""
    text = [i for s in list(seqs) for i in s]
    clrs =  { "A" : "#1e67b6",
    "C" : "#00a391",
    "D" : "#ea42fc",
    "E" : "#109c4b",
    "F" : "#fed700",
    "G" : "#8d4712",
    "H" : "#ff8e00",
    "I" : "#d82626",
    "K" : "#109c4b",
    "L" : "#d82626",
    "M" : "#d82626",
    "N" : "#ea42fc",
    "P" : "#ffa9e3",
    "Q" : "#109c4b",
    "R" : "#109c4b",
    "S" : "#1e67b6",
    "T" : "#1e67b6",
    "V" : "#d82626",
    "W" : "#fed700",
    "Y" : "#fed700", "-" : "black"}
    colors = [clrs[i] for i in text]
    return colors
def view_alignment(aln, fontsize="9pt", plot_width=800):
    """Bokeh sequence alignment view"""

    #make sequence and id lists from the aln object
    seqs = [rec.seq for rec in (aln)]
    ids = [rec.id for rec in aln]    
    text = [i for s in list(seqs) for i in s]
    colors = get_colors(seqs)    
    N = len(seqs[0])
    S = len(seqs)    
    width = .4

    x = np.arange(1,N+1)
    y = np.arange(0,S,1)
    #creates a 2D grid of coords from the 1D arrays
    xx, yy = np.meshgrid(x, y)
    #flattens the arrays
    gx = xx.ravel()
    gy = yy.flatten()
    #use recty for rect coords with an offset
    recty = gy+.5
    h= 1/S
    #now we can create the ColumnDataSource with all the arrays
    source = ColumnDataSource(dict(x=gx, y=gy, recty=recty, text=text, colors=colors))
    plot_height = len(seqs)*15+50
    x_range = Range1d(0,N+1, bounds='auto')
    if N>100:
        viewlen=100
    else:
        viewlen=N
    #view_range is for the close up view
    view_range = (0,viewlen)
    tools="xpan, xwheel_zoom, reset, save"

    #entire sequence view (no text, with zoom)
    p = figure(title=None, plot_width= plot_width, plot_height=50,
               x_range=x_range, y_range=(0,S), tools=tools,
               min_border=0, toolbar_location='below')
    rects = Rect(x="x", y="recty",  width=1, height=1, fill_color="colors",
                 line_color=None, fill_alpha=0.6)
    p.add_glyph(source, rects)
    p.yaxis.visible = False
    p.grid.visible = False  

    #sequence text view with ability to scroll along x axis
    p1 = figure(title=None, plot_width=plot_width, plot_height=plot_height,
                x_range=view_range, y_range=ids, tools="xpan,reset",
                min_border=0, toolbar_location='below')#, lod_factor=1)          
    glyph = Text(x="x", y="y", text="text", text_align='center',text_color="black",
                text_font="monospace",text_font_size=fontsize)
    rects = Rect(x="x", y="recty",  width=1, height=1, fill_color="colors",
                line_color=None, fill_alpha=0.4)
    p1.add_glyph(source, glyph)
    p1.add_glyph(source, rects)

    p1.grid.visible = False
    p1.xaxis.major_label_text_font_style = "bold"
    p1.yaxis.minor_tick_line_width = 0
    p1.yaxis.major_tick_line_width = 0

    p = gridplot([[p],[p1]], toolbar_location='below')
    show(p)
    return p

def codeml_creating_file():
        
    c078 = """          seqfile = Reverse_Translation_Seq.txt-gb1.fst * fasta file
         treefile = Species_Phylogenetic_tree_newick_nodistances.nwk * 
          outfile = codeml078_mlc.txt

            noisy = 9   * 0,1,2,3,9: how much rubbish on the screen
          verbose = 1   * 1: detailed output, 0: concise output
          runmode = 0   * 0: user tree;  1: semi-automatic;  2: automatic
                        * 3: StepwiseAddition; (4,5):PerturbationNNI 

          seqtype = 1   * 1:codons; 2:AAs; 3:codons-->AAs
        CodonFreq = 2   * 0:1/61 each, 1:F1X4, 2:F3X4, 3:codon table
            clock = 0   * 0: no clock, unrooted tree, 1: clock, rooted tree
            model = 0   * 0 - site models 2 - branch and branch-site models
                        * models for codons:
                            * 0:one, 1:b, 2:2 or more dN/dS ratios for branches

          NSsites = 0 7 8   * dN/dS among sites. 0:no variation, 1:neutral, 2:positive
            icode = 0   * 0:standard genetic code; 1:mammalian mt; 2-10:see below

        fix_kappa = 0   * 1: kappa fixed, 0: kappa to be estimated
            kappa = 2   * initial or fixed kappa
        fix_omega = 0   * 1: omega or omega_1 fixed, 0: estimate 
            omega = 2   * initial or fixed omega, for codons or codon-transltd AAs

        fix_alpha = 1   * 0: estimate gamma shape parameter; 1: fix it at alpha
            alpha = .0  * initial or fixed alpha, 0:infinity (constant rate)
           Malpha = 0   * different alphas for genes
            ncatG = 4   * # of categories in the dG or AdG models of rates

            getSE = 0   * 0: don't want them, 1: want S.E.s of estimates
     RateAncestor = 0   * (1/0): rates (alpha>0) or ancestral states (alpha=0)
           method = 0   * 0: simultaneous; 1: one branch at a time
      fix_blength = 0  * 0: ignore, -1: random, 1: initial, 2: fixed, 3: proportional
        cleandata = 0  * remove sites with ambiguity data (1:yes, 0:no)?


    * Specifications for duplicating results for the small data set in table 1
    * of Yang (1998 MBE 15:568-573).
    * see the tree file lysozyme.trees for specification of node (branch) labels"""

    c8a = """          seqfile = Reverse_Translation_Seq.txt-gb1.fst * fasta file
         treefile = Species_Phylogenetic_tree_newick_nodistances.nwk * 
          outfile = codeml8a_mlc.txt

            noisy = 9   * 0,1,2,3,9: how much rubbish on the screen
          verbose = 1   * 1: detailed output, 0: concise output
          runmode = 0   * 0: user tree;  1: semi-automatic;  2: automatic
                        * 3: StepwiseAddition; (4,5):PerturbationNNI 

          seqtype = 1   * 1:codons; 2:AAs; 3:codons-->AAs
        CodonFreq = 2   * 0:1/61 each, 1:F1X4, 2:F3X4, 3:codon table
            clock = 0   * 0: no clock, unrooted tree, 1: clock, rooted tree
            model = 0   * 0 - site models 2 - branch and branch-site models
                        * models for codons:
                            * 0:one, 1:b, 2:2 or more dN/dS ratios for branches

          NSsites = 8  * dN/dS among sites. 0:no variation, 1:neutral, 2:positive
            icode = 0   * 0:standard genetic code; 1:mammalian mt; 2-10:see below

        fix_kappa = 0   * 1: kappa fixed, 0: kappa to be estimated
            kappa = 2   * initial or fixed kappa
        fix_omega = 1   * 1: omega or omega_1 fixed, 0: estimate 
            omega = 1   * initial or fixed omega, for codons or codon-transltd AAs

        fix_alpha = 1   * 0: estimate gamma shape parameter; 1: fix it at alpha
            alpha = .0  * initial or fixed alpha, 0:infinity (constant rate)
           Malpha = 0   * different alphas for genes
            ncatG = 4   * # of categories in the dG or AdG models of rates

            getSE = 0   * 0: don't want them, 1: want S.E.s of estimates
     RateAncestor = 0   * (1/0): rates (alpha>0) or ancestral states (alpha=0)
           method = 0   * 0: simultaneous; 1: one branch at a time
      fix_blength = 0  * 0: ignore, -1: random, 1: initial, 2: fixed, 3: proportional
        cleandata = 0  * remove sites with ambiguity data (1:yes, 0:no)?


    * Specifications for duplicating results for the small data set in table 1
    * of Yang (1998 MBE 15:568-573).
    * see the tree file lysozyme.trees for specification of node (branch) labels"""

    c2a = """          seqfile = Reverse_Translation_Seq.txt-gb1.fst * fasta file
         treefile = Species_Phylogenetic_tree_newick_Interst#.nwk * 
          outfile = codeml2a_mlc.txt

            noisy = 9   * 0,1,2,3,9: how much rubbish on the screen
          verbose = 1   * 1: detailed output, 0: concise output
          runmode = 0   * 0: user tree;  1: semi-automatic;  2: automatic
                        * 3: StepwiseAddition; (4,5):PerturbationNNI 

          seqtype = 1   * 1:codons; 2:AAs; 3:codons-->AAs
        CodonFreq = 2   * 0:1/61 each, 1:F1X4, 2:F3X4, 3:codon table
            clock = 0   * 0: no clock, unrooted tree, 1: clock, rooted tree
            model = 2   * 0 - site models 2 - branch and branch-site models
                        * models for codons:
                            * 0:one, 1:b, 2:2 or more dN/dS ratios for branches

          NSsites = 2  * dN/dS among sites. 0:no variation, 1:neutral, 2:positive
            icode = 0   * 0:standard genetic code; 1:mammalian mt; 2-10:see below

        fix_kappa = 0   * 1: kappa fixed, 0: kappa to be estimated
            kappa = 2   * initial or fixed kappa
        fix_omega = 0   * 1: omega or omega_1 fixed, 0: estimate 
            omega = 2   * initial or fixed omega, for codons or codon-transltd AAs

        fix_alpha = 1   * 0: estimate gamma shape parameter; 1: fix it at alpha
            alpha = .0  * initial or fixed alpha, 0:infinity (constant rate)
           Malpha = 0   * different alphas for genes
            ncatG = 4   * # of categories in the dG or AdG models of rates

            getSE = 0   * 0: don't want them, 1: want S.E.s of estimates
     RateAncestor = 0   * (1/0): rates (alpha>0) or ancestral states (alpha=0)
           method = 0   * 0: simultaneous; 1: one branch at a time
      fix_blength = 0  * 0: ignore, -1: random, 1: initial, 2: fixed, 3: proportional
        cleandata = 0  * remove sites with ambiguity data (1:yes, 0:no)?


    * Specifications for duplicating results for the small data set in table 1
    * of Yang (1998 MBE 15:568-573).
    * see the tree file lysozyme.trees for specification of node (branch) labels"""

    c2 = """          seqfile = Reverse_Translation_Seq.txt-gb1.fst * fasta file
         treefile = Species_Phylogenetic_tree_newick_Interst#.nwk * 
          outfile = codeml2_mlc.txt

            noisy = 9   * 0,1,2,3,9: how much rubbish on the screen
          verbose = 1   * 1: detailed output, 0: concise output
          runmode = 0   * 0: user tree;  1: semi-automatic;  2: automatic
                        * 3: StepwiseAddition; (4,5):PerturbationNNI 

          seqtype = 1   * 1:codons; 2:AAs; 3:codons-->AAs
        CodonFreq = 2   * 0:1/61 each, 1:F1X4, 2:F3X4, 3:codon table
            clock = 0   * 0: no clock, unrooted tree, 1: clock, rooted tree
            model = 2  * 0 - site models 2 - branch and branch-site models
                        * models for codons:
                            * 0:one, 1:b, 2:2 or more dN/dS ratios for branches

          NSsites = 2   * dN/dS among sites. 0:no variation, 1:neutral, 2:positive
            icode = 0   * 0:standard genetic code; 1:mammalian mt; 2-10:see below

        fix_kappa = 0   * 1: kappa fixed, 0: kappa to be estimated
            kappa = 2   * initial or fixed kappa
        fix_omega = 1   * 1: omega or omega_1 fixed, 0: estimate 
            omega = 1   * initial or fixed omega, for codons or codon-transltd AAs

        fix_alpha = 1   * 0: estimate gamma shape parameter; 1: fix it at alpha
            alpha = .0  * initial or fixed alpha, 0:infinity (constant rate)
           Malpha = 0   * different alphas for genes
            ncatG = 4   * # of categories in the dG or AdG models of rates

            getSE = 0   * 0: don't want them, 1: want S.E.s of estimates
     RateAncestor = 0   * (1/0): rates (alpha>0) or ancestral states (alpha=0)
           method = 0   * 0: simultaneous; 1: one branch at a time
      fix_blength = 0  * 0: ignore, -1: random, 1: initial, 2: fixed, 3: proportional
        cleandata = 0  * remove sites with ambiguity data (1:yes, 0:no)?


    * Specifications for duplicating results for the small data set in table 1
    * of Yang (1998 MBE 15:568-573).
    * see the tree file lysozyme.trees for specification of node (branch) labels"""
    codeml078 = open("codeml078.ctl" , "w")
    codeml078.write(c078)
    codeml8a = open("codeml8a.ctl" , "w")
    codeml8a.write(c8a)
    codeml2a = open("codeml2a.ctl","w")
    codeml2a.write(c2a)
    codeml2 = open("codeml2.ctl", "w")
    codeml2.write(c2)
    
    
def number_of_fetched_species()
    path = os.getcwd()
    list_files = glob.glob("*.gene")

    counter = [["Name", "Number of Species"]]
    x = open("output.txt",'w')
    for i in list_files:
        reading = open(path + '/' + i + '/' + 'CodingSequences.fasta', 'r')
        reading2 = reading.read()
        counter.append([i, reading2.count('>')])
    df = pd.DataFrame(counter)
    df.to_csv("fetched_species.csv")

codeml_creating_file()


