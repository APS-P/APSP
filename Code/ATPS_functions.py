# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hg1E21ppVMNk6FJFcasdGxOpo9_C-LOj
"""


from Bio import Entrez
from Bio.Seq import Seq
from Bio import AlignIO
from Bio import Phylo
from Bio.Phylo import TreeConstruction
from Bio.Phylo.TreeConstruction import DistanceCalculator, DistanceTreeConstructor
from Bio import SeqIO
from Bio.SeqRecord import SeqRecord
import subprocess
import os.path
import sys
import shutil
import pandas as pd
from scipy.stats import chi2
import glob
import matplotlib.pyplot as plt
import os
import numpy as np
import panel as pn
pn.extension()
from bokeh.plotting import figure, show
from bokeh.models import ColumnDataSource, Range1d
from bokeh.models.glyphs import Text, Rect
from bokeh.layouts import gridplot
import csv


def get_max_str_index(lst):
    return max(enumerate(lst), key=lambda x: len(x[1]))

def fetchingbyspecies(protein,List_species,interest, fetch, gene_path = None, inp_file = None):
    """this function fetches all the required data from ncbi for a specific gene
        or protein, applies all the required filters, and structure the data to
        be used later in the pipeline.
        the function writes files to a specific directory that will be used
        later in the pipeline

    Args:
        protein (string): protein name
        List_species (list): list of species
        interest (string): the species of interest for further analysis
        fetch (int): fetching method (either from existing fasta files or from NCBI nuccore database)
        gene_path (_type_): the path to the fasta files if the fetching method is 0
        inp_file (_type_): file name of the input fasta file that contains all the species of a gene
        email (string): user email

    Returns:
        list_empty: a true or false value indicating if the gene was found or not
    """
    
    if fetch == 1:
        # input email from user
        Entrez.email = "example@gmail.com"
        # check if email is entered
        if not Entrez.email:
            sys.exit ("you must add your email address")
        species_list = []
        # dictionary that stores all sequences with names
        seq_dict = {}
        protein_dict = {}
        filter_gene = f"[gene={protein}]"
        for i in List_species:
            # fetching nucleotide sequences from ncbi nuccore database using a term that includes refseq filter and mrna filter
            Searched_Term = f"{i}[Organism] OR {i}[All Fields] AND {protein}[Title] AND (biomol_mrna[PROP] AND refseq[filter])"
            handle = Entrez.esearch(db="nuccore", term = Searched_Term, retmax = 4000, usehistory="y", idtype="acc")
            search_results = Entrez.read(handle)
            # list of accession numbers
            acc_list = search_results["IdList"]
            # list of gene count
            count = int(search_results["Count"])
            # web environment
            webenv = search_results["WebEnv"]
            # query key
            query_key = search_results["QueryKey"]
            begin = 0
            indiced_list = []
            # fetching all the genes using accession numbers in the web environment
            fetch_handle = Entrez.efetch(db="nuccore",
                                             rettype="fasta_cds_na",
                                             retmode="text",
                                             retmax=count,
                                             webenv=webenv,
                                             query_key=query_key,
                                             idtype="acc")
            data = fetch_handle.read()
            fetch_handle.close()
            accession_list = []
            # parsing through the genes, and removing the headers which leaves only the name of the gene as a header
            for gene in str(data).split('\n\n')[:-1]: 
                sequence = ''
                if filter_gene.lower() in gene.lower(): ## making sure that the fetched gene name is the same as the input gene name
                    start = gene.find("|")
                    end = gene.find(".")
                    accession_num = gene[start+1:end+2]
                    accession_list.append(accession_num)
                    sequence = gene[gene.find(']\n')+1:].replace("\n", "").strip()
                    indiced_list.append(sequence)
            if not indiced_list:
                print(f"We could not find any sequences matching our criteria for this species{i}")
                continue
            # making sure that the fetched genes meet the standards of coding sequences
            ## fetching gene with maximum length
            while indiced_list:
                max_gene = get_max_str_index(indiced_list)
                if "*" not in str(Seq(max_gene[1]).translate())[:-1] and (str(max_gene[1]).startswith("ATG")) and str(Seq(max_gene[1]).translate()).endswith('*'):
                    seq_dict[i] = max_gene[1]
                    break
                else:
                    indiced_list.pop(max_gene[0])
            if seq_dict[i] == '':
                if i == interest:
                    print(interest," not found. another gene will be set to be the gene of interest")
                    carry = List_species.copy()
                    carry.remove(i)
                    interest = carry[0]
                seq_dict.pop(i, None)
    else:
        seq_dict = _extracted_from_fetchingbyspecies_95(gene_path, inp_file)
    for specie in seq_dict.keys():
        to_trans = Seq(seq_dict[specie])
        protein_dict[specie] = str(to_trans.translate())
    

    with open("CodingSequences.fasta", "w") as out_handle:

        sequences = ''
        for species, sequence in seq_dict.items():
            seq = SeqRecord(Seq(sequence), id=species.replace(' ','_').lower(), description= "").format("fasta")
            sequences += seq
        out_handle.write(sequences)

    with open("ProteinSequences.fasta", "w") as out_handle:

        sequences = ''
        for species, sequence in protein_dict.items():
            seq = SeqRecord(Seq(sequence), id=species.replace(' ','_').lower(), description= "").format("fasta")
            sequences += seq
        out_handle.write(sequences)
    
    valueList = list(protein_dict.values())
    list_empty = bool(valueList)
    return list_empty, interest 



# TODO Rename this here and in `fetchingbyspecies`
def _extracted_from_fetchingbyspecies_95(gene_path, inp_file):
    # fetching genes from files
    gene_open = open(gene_path + "/" + inp_file, 'r')
    gene_instance = gene_open.read()
        ## to be changed
    # if "\n\nA" not in gene_instance or "\n\n>" not in gene_instance:
    #     addlines(f"{str(gene_path)}/" + inp_file, "CodingSequences.fasta")
    coding_seqopen = open("CodingSequences.fasta")
    seq_instances = coding_seqopen.read()
    seq_lisinst = seq_instances.split("\n\n")
    seq_lisinst = list(filter(('').__ne__, seq_lisinst))
    result = zip((seq_lisinst[r].replace('\n', '').replace('>', '') for r in range(0, len(seq_lisinst), 2)), (seq_lisinst[r] for r in range(1, len(seq_lisinst), 2)))
    result = dict(result)
    return result


# imported libraries below
# This is incomplete, we need to add f'' string
file_path = "ProteinSequences.fasta"
def diff_aligners(file_path , align_type):
    """the diff_aligners function carry out the alignment process with various alignment method (muscle, clustalo and mafft)

    Args:
        file_path (_type_): path to sequences file
        align_type (_type_): method of alignment "mu" for muscle, "cl" for clustalo and "mf" for mafft
    """
    
    if align_type == "mu":
        try:
            subprocess.run('(muscle -in ' + file_path + ' -out Alignment.ali)', shell=True, check=True)
        except Exception:
            os.system("sudo apt install muscle")
            subprocess.run('(muscle -in ' + file_path + ' -out Alignment.ali)', shell=True, check=True)

    elif align_type == "cl":
        print('Running Clustalo. Please wait till it finishes...')
        subprocess.run('(clustalo -i ' + file_path + ' -o Alignment.ali)', shell=True, check=True)
        print('Process completed...')
    elif align_type == "mf":
        subprocess.run('(mafft ' + file_path + ' > Alignment.ali)', shell=True, check=True)
    else:
        print('The program will now exit.')

def reversedd(interest):
    """this function returns the aligned protein sequence to gene sequence

    Args:
        interest (type:string): the gene of interest
    """
    with open("Reverse_Translation_Seq.txt" , "w") as fasta:
        sequence_dict = SeqIO.to_dict(SeqIO.parse("CodingSequences.fasta", "fasta"))
        protein_dict = SeqIO.to_dict(SeqIO.parse("Alignment.ali", "fasta"))
        species = list(sequence_dict.keys())
        species.remove(interest.lower())  
        species.insert(0, interest.lower()) 
        print(species)
        for key in species:
            sequence_dict[key] = [str(sequence_dict[key].seq[i : i + 3]) for i in range(0, len(sequence_dict[key]), 3)]
            protein_dict[key] = str(protein_dict[key].seq)

        for key in sequence_dict.keys():
            output = ""
            counter = 0
            for i in range(len(protein_dict[key])):
                if protein_dict[key][i] == "-":
                    output += "---"
                else:
                    output += sequence_dict[key][counter]
                    counter += 1
            seq = SeqRecord(Seq("".join(output)), id=key, description= "").format("fasta")
            fasta.write(seq)
            


def Gblocks():
    """
        this function applies the Gblocks tool to eliminate the poorly aligned positions and divergent regions of an alignment
    """
    os.system('Gblocks_0.91b/Gblocks Reverse_Translation_Seq.txt -t=c -e=-gb1 -b5=h -d=y -b2=0')

def convert_fst_phy():
    """
        function that converts specific fasta file to phylip file 
    """
    os.system("java -jar jmodeltest-2.1.7/jModelTest.jar -d Reverse_Translation_Seq.txt-gb1 -getPhylip")

def rem_spaces():
    """
        f
    """
    f = open("Reverse_Translation_Seq.txt-gb1" , "r")
    m = open("Reverse_Translation_Seq.txt-gb1.fst" , "a") #this file include the data in  Reverse_Translation_Seq.txt-gb1 without internal gaps.
    for  i in f.read():
        if i != " ":
            m.writelines(i)
        if i == " ":
            continue
        
def jmodel():
    """
       this function execute the jmodel test command
    """
    os.system("java -jar jmodeltest-2.1.7/jModelTest.jar -d Reverse_Translation_Seq.txt-gb1.phy -s 11 -g 4 -t BIONJ -f -i -AICc -o Jmodeltest_output")


def parsing_jmodeltest():
    """
    parsing jmodeltest to find the best substitution model

    Returns:
        partition: 
        freq: frequencies of A, T, G, C
        pinvar: 
    """
    lis = []
    filt = []
    flag = 0
    freq = ''
    partition = ''
    pinvar = ''
    with open("Jmodeltest_output","rb") as f: lis.extend(f.readlines())
    for i in lis:
        if 'Model selected:' in str(i):
            flag = 1
        if 'partition = ' in str(i):
            partition = str(i).replace("b'   partition = ", '').strip('\n').replace("'",'')[:6]
        if 'p-inv = ' in str(i):
            pinvar = str(i).replace("b'   p-inv = ", '').strip('\n').replace("'",'')[:6]
        if flag == 1:
            filt.append(str(i))
        if 'Tree ' in str(i):
            flag = 0
    for i in filt:
        if 'freqA' in str(i):
            freq += str(i).replace("b'   freqA = ", '').strip('\n').replace("'",'')[:6]
            freq += ','
        if 'freqC' in str(i):
            freq += str(i).replace("b'   freqC = ", '').strip('\n').replace("'",'')[:6]
            freq += ','
        if 'freqG' in str(i):
            freq += str(i).replace("b'   freqG = ", '').strip('\n').replace("'",'')[:6]
            freq += ','
        if 'freqT' in str(i):
            freq += str(i).replace("b'   freqT = ", '').strip('\n').replace("'",'')[:6]
    return partition, freq, pinvar

def spare_parse():
    """
    parsing jmodeltest to find the second best substitution model if there is insufficient data(pinvar, frequencies, partition) for the best model

    Returns:
        partition: 
        freq: frequencies of A, T, G, C
        pinvar: 
    """
    open_ = open("Jmodeltest_output" , "r")
    read_ = open_.read()
    names = []
    freq = ""
    jmodel_out = []
    list_name = []
    start_name = read_.find("cumWeight\n-")
    stop_name = read_.find("-\n-lnL")
    list_name = read_[start_name + 85 :stop_name - 84]
    list_name1 = [line[:line.index(" ")] for line in list_name.split("\n")]
    for i in list_name1[1:]:
        start_model = read_.find("   Model = " + i)
        stop_model = read_[start_model:].find("\n \n")
        model_list = read_[start_model:start_model + stop_model]
        if "freqA = " not in model_list:
            continue
        for i in model_list.split("\n"):
            if "partition =" in i:
                partition = str(i).replace("   partition = ", '').strip('\n').replace("'",'')[:6]
            if 'p-inv = ' in str(i):
                pinvar = str(i).replace("   p-inv = ", '').strip('\n').replace("'",'')[:6]
            if 'freqA' in str(i):
                freq += str(i).replace("   freqA = ", '').strip('\n').replace("'",'')[:6]
                freq += ','
            if 'freqC' in str(i):
                freq += str(i).replace("   freqC = ", '').strip('\n').replace("'",'')[:6]
                freq += ','
            if 'freqG' in str(i):
                freq += str(i).replace("   freqG = ", '').strip('\n').replace("'",'')[:6]
                freq += ','
            if 'freqT' in str(i):
                freq += str(i).replace("   freqT = ", '').strip('\n').replace("'",'')[:6]
        break
    return partition, freq, pinvar

def phyml(partition, freq, pinvar):
    """
    running the phylogenetic tree

    Args:
        partition (string): _description_
        freq (string): _description_
        pinvar (string): _description_
    """
    os.system("phyml -i Reverse_Translation_Seq.txt-gb1.phy -d nt -b 100 -f e -m " + partition + ' -f ' + freq + " -v " + pinvar )
    os.rename("Reverse_Translation_Seq.txt-gb1.phy_phyml_boot_trees.txt", "Species_Phylogenetic_boot_trees.txt")
    os.rename("Reverse_Translation_Seq.txt-gb1.phy_phyml_tree.txt", "Species_Phylogenetic_tree.txt")
    os.rename("Reverse_Translation_Seq.txt-gb1.phy_phyml_stats.txt", "Species_Phylogenetic_stats.txt")
    os.rename("Reverse_Translation_Seq.txt-gb1.phy_phyml_boot_stats.txt", "Species_Phylogenetic_boot_stats.txt")
    #os.rename("Reverse_Translation_Seq.txt-gb1.phy", "")    
    
def convert_to_newickTree():
    """convert phylogenetic tree file into newick format and rooted tree
    """
    aln = AlignIO.read('Reverse_Translation_Seq.txt-gb1.phy', 'phylip-relaxed')
    t = Phylo.read("Species_Phylogenetic_tree.txt", "newick")
    scorer = Phylo.TreeConstruction.ParsimonyScorer()
    searcher = Phylo.TreeConstruction.NNITreeSearcher(scorer)
    constructor = Phylo.TreeConstruction.ParsimonyTreeConstructor(searcher, t)
    pars_tree = constructor.build_tree(aln)
    Phylo.write(pars_tree, "Species_Phylogenetic_tree_phyloxl.xml", "phyloxml")
    Phylo.convert("Species_Phylogenetic_tree_phyloxl.xml", "phyloxml", "Species_Phylogenetic_tree_newick.nwk", "newick")

def parsing_treefile():
    """
    removing distances from the phylogenetic tree file because codeml requires the tree without distances
    """
    liss = []
    with open("Species_Phylogenetic_tree_newick.nwk","rb") as m: liss.extend(str(m.readlines()))
    trim = ''.join(liss)
    results = ''.join([i for i in trim if not i.isdigit() and i != ':' and i != '.' and i != "\n"])[3:-4]
    y = open("Species_Phylogenetic_tree_newick_nodistances.nwk","w")
    y.writelines(results)

#sys.exit(0)



def BEB(path):# try and except
    """getting the BEB output from codeml for the sites under positive selection

    Args:
        path (string): path to current directory

    Returns:
        BEB_list: list of sites under positive selection
    """
    codeml078 = open(path + "/" + "codeml078/codeml078_mlc.txt", "r")
    BEB_read = codeml078.read()
    start = BEB_read.find("Bayes Empirical Bayes (BEB)") ## getting 
    end = BEB_read.find("the grid") ## getting
    BEB_list = []
    BEB_list = BEB_read[start : end].split("\n\n")[2].replace("         ", ",").replace("*        ", "*,").replace("      ", ",").replace("**       ", "**,")

    BEB_list = '\n'.join([','.join([line.strip().replace(" ", ",").split(",", 3)[n] for n in range(3)]) for line in BEB_list.split('\n')])

    return BEB_list


def Positive_selection_sites(BEB_list, interest, path):
    """this function return the sequence with the original positions before the sequence trimming by gblocks 

    Args:
        BEB_list (sequence): the BEB positions resulted from codeml
        interest (string): the interst species 
        path (string): file path in the directory 

    Returns:
        list(sequence): the original position before the sequence trimming which occuring by gblocks 
    """
    original = path + "/" + "Reverse_Translation_Seq.txt-gb1.htm" #changing the gbocks file out put from HTML to txt
    target = path + "/" + "Reverse_Translation_Seq.txt-gb1.txt"
    shutil.copyfile(original, target)
    gblocks_file = open(path + "/" + "Reverse_Translation_Seq.txt-gb1.txt", "r") # open gblocks file 
    Positive_selection_sites = [] 
    counter = 0
    BEB = ''.join(BEB_list)
    BEB_position = BEB.replace("\n", ",").split(",")[::3]
    BEB_positions = [int(BEB_position[i + 1]) - int(BEB_position[i]) for i in range(len(BEB_position) - 1)]

    BEB_positions.insert(0, int(BEB_position[0]))
    g_postiotns = [i.replace("Flanks: ", "").replace("\n", "").replace("[", "").replace("]", "").replace("  ", " ").strip().split(" ") for i in gblocks_file.readlines() if "Flanks: " in i]

    posi_listt = g_postiotns[0]
    posi_listt = [int(i) // 3 for i in posi_listt]
    posi_list = [[posi_listt[i], posi_listt[i + 1]] for i in range(0, len(posi_listt) - 1, 2)]

    carrier = [i[1] - i[0] for i in posi_list]
    for i in BEB_positions:
        while carrier[0] != 0:
            if i < carrier[0]:
                posi_list[0][0] += i
                Positive_selection_sites.append(posi_list[0][0])
                carrier[0] -= i
                break
            elif i == carrier[0]:
                Positive_selection_sites.append(posi_list[0][1])
                posi_list.pop(0)
                carrier.pop(0)
                break
            else:
                i -= carrier[0]
                carrier.pop(0)
                posi_list.pop(0)
    ps_list = [f'{str(i)},{str(Positive_selection_sites[j])}' for j, i in enumerate(BEB_list.split("\n"))]

    ps_list = '\n'.join(ps_list)
    BEB_csv = open(path + "/" + "BEB.csv", "w")
    BEB_csv.write(ps_list)
    return Positive_selection_sites




#sys.exit(0)

def hashing(interest):  
    """
        Function that sets an indicator for the gene of interest for codeml

    Args:
        interest (_type_): _description_
    """
    newick_open = open("Species_Phylogenetic_tree_newick_nodistances.nwk")
    newick_create = open("Species_Phylogenetic_tree_newick_Interst#.nwk", 'w')
    newick_read = newick_open.read()
    newick_list = newick_read.split(',')
    result = newick_read.find(str(interest.lower()))
    print(result)
    result += len(interest)
    print(result)
    newick_read = newick_read[:result] + " #1" + newick_read[result:]
    newick_open.close()
    print(newick_read)
    newick_create.write(newick_read)
    
def model078():
    """
        Function that Runs Codeml models 0,7,8
    """
    f = open("codeml.ctl", "w")
    m = open("codeml078.ctl" , "r")
    f.writelines(m)
    f.close()
    os.system("codeml")
    
def model8a():
    """
        Function that Runs Codeml model 8a
    """
    f = open("codeml.ctl", "w")
    m = open("codeml8a.ctl" , "r")
    f.writelines(m)
    f.close()
    os.system("codeml")

def model2a():
    """
        Function that Runs Codeml model 2a
    """
    f = open("codeml.ctl", "w")
    m = open("codeml2a.ctl" , "r")
    f.writelines(m)
    f.close()
    os.system("codeml")

#sys.exit(0)
def model2():
    """
        Function that Runs Codeml model 2
    """
    f = open("codeml.ctl", "w")
    m = open("codeml2.ctl" , "r")
    f.writelines(m)
    f.close()
    os.system("codeml")

#sys.exit(0)

 
def download():
    path = os.getcwd()
    list_files = glob.glob(path + "/*")
    print(path)
    if path + "/jmodeltest-2.1.7.zip" not in list_files:
        os.system('wget "https://github.com/ddarriba/jmodeltest2/releases/download/v2.1.9r20160115/jmodeltest-2.1.7-win32.zip" -O jmodeltest-2.1.7.zip')
        os.system("jar xvf jmodeltest-2.1.7.zip")
    if path + "/Gblocks_Linux64_0.91b.tar.Z" not in list_files:
        os.system('wget "https://drive.google.com/uc?export=download&id=1syZCAT748J8_1BOyLOtuRgHXdRK54J2k" -O Gblocks_Linux64_0.91b.tar.Z')
        os.system("tar -xf Gblocks_Linux64_0.91b.tar.Z")

 
     
def saving_(gene_name):
    path = os.getcwd()
    new_dir = path + "/" + gene_name + ".gene"
    print(new_dir)
    file_list = glob.glob(path + "/*")
    file_list.remove(path + "/ATPS.py")
    file_list.remove(path + "/importt.py")
    file_list.remove(path + "/ATPS_functions.py")
    file_list.remove(path + "/Study_Output.csv")
    try:
        os.system("mkdir " + new_dir)
    except OSError:
        print(f"Creation of the directory {path} failed")
    else:
        print(f"Successfully created the directory {path} ")

    for i in file_list:
        print(i)
        try:
            shutil.copy(i , new_dir, follow_symlinks=True)
        except:
            os.system("cp -R " + i + " " + new_dir)
        
def deletion_files():
    """
        a function that deletes the unwanted files
    """
    try:
        os.remove("Alignment.ali")
    except:
        pass
    try:
        os.remove("BEB.csv")
    except:
        pass
    try:
        os.remove("Sequences_Alignment.ali")
    except:
        pass
    try:
        os.remove("codeml.ctl")
    except:
        pass
    try:
        os.remove("CodingSequences.fasta")
    except:
        pass
    try:
        os.remove("Species_Phylogenetic_tree_newick_nodistances.nwk")
    except:
        pass
    try:
        os.remove("Reverse_Translation_Seq.txt-gb1.fst")
    except:
        pass
    try:
        os.remove("Reverse_Translation_Seq.txt")
    except:
        pass
    try:
        os.remove("Reverse_Translation_Seq.txt-gb1")
    except:
        pass
    try:
        os.remove("Reverse_Translation_Seq.txt-gb1.htm")
    except:
        pass
    try:
        os.remove("Reverse_Translation_Seq.txt-gb1.phy")
    except:
        pass
    try:
        os.remove("Species_Phylogenetic_boot_stats.txt")
    except:
        pass
    try:
        os.remove("Species_Phylogenetic_boot_trees.txt")
    except:
        pass
    try:
        os.remove("Species_Phylogenetic_stats.txt")
    except:
        pass
    try:
        os.remove("Species_Phylogenetic_tree.txt")
    except:
        pass
    try:
        os.remove("Reverse_Translation_Seq.txt-gb1PS")
    except:
        pass
    try:
        os.remove("Species_Phylogenetic_tree_newick.nwk")
    except:
        pass
    try:
        os.remove("Species_Phylogenetic_tree_phyloxl.xml")
    except:
        pass
    try:
        os.remove("interest.txt")
    except:
        pass
    try:
        os.remove("Jmodeltest_output")
    except:
        pass
    try:
        os.remove("ProteinSequences.fasta")
    except:
        pass
    try:
        os.remove("Species_Phylogenetic_tree_newick_nodistances.nwk")
    except:
        pass
    try:
        os.remove("Species_Phylogenetic_tree.nwk")
    except:
        pass
    try:
        os.remove("Reverse_Translation_Seq.txt-gb1.txt")
    except:
        pass
    try:
        os.remove("phast_output.xlsx")
    except:
        pass
    try:
        os.remove("phyloFit.txt")
    except:
        pass
    try:
        del_paths = glob.glob(os.path.join(path,'*.mod'))
        for del_path in del_paths:
            os.remove(del_path)
    except:
        pass
    try:
        os.remove("wigscore")
    except:
        pass
    try:
        os.remove("wigscore.png")
    except:
        pass
    try:
        os.remove("positive_selection_sites.txt")
    except:
        pass



def del_codeml_dir():
    """removing unwanted files
    """
    shutil.rmtree("codeml2")
    shutil.rmtree("codeml2a")
    shutil.rmtree("codeml8a")
    shutil.rmtree("codeml078")
    
def creat_codeml_dir():
    """creating codeml directories
    """
    try:
        os.mkdir("codeml2")
    except:
        pass
    try:
        os.mkdir("codeml2a")
    except:
        pass
    try:    
        os.mkdir("codeml8a")
    except:
        pass
    try:    
        os.mkdir("codeml078")
    except:
        pass
def path_dir():
    return os.getcwd()

def phast(gene):
    """carry out phast operation to get the wigscores

    Args:
        gene (_type_): _description_
    """
    original = r"Species_Phylogenetic_tree.txt"
    target = r"Species_Phylogenetic_tree.nwk"
    shutil.copyfile(original , target)
    try:
        os.system("phyloFit --tree Species_Phylogenetic_tree.nwk Alignment.ali > "+gene+".mod")
    except:
        os.system("sudo apt-get install -y phast")
        os.system("phyloFit --tree Species_Phylogenetic_tree.nwk Alignment.ali > " + gene + ".mod")
    try:
       
        shutil.move('phyloFit.mod', 'phyloFit.txt')
    except:
        os.system("sudo apt-get install -y phast")
        os.system("phyloFit --tree Species_Phylogenetic_tree.nwk Alignment.ali > " + gene + ".mod")
        shutil.move('phyloFit.mod', 'phyloFit.txt')
        
    os.system("phyloP --wig-scores --method LRT --mode CONACC phyloFit.txt Alignment.ali > wigscore")
    file1 = open("wigscore","r")
    df = pd.read_table('wigscore')
    df.to_excel('phast_output.xlsx', 'Sheet1')
    #df['fixed'] = df['fixed'].str.replace(r'\D', '').astype(float)
    df.columns.values[0] = "Name"
    df=df[df.Name.str.contains(r'[.]')]
    print(df.head())
    df.head()
    df=df.astype(float)
    plt.style.use('seaborn-whitegrid')
    df=df.astype(float)
    p=df.plot.line(color="#0e6655")
    fig1 = plt.gcf()
    p.set_facecolor('#d0d3d4')
    #plt.draw()
    #try:
    #    plt.show()
    #except:
    #    plt.show()
    #else:
    fig1.savefig('wigscore.png', dpi=100)
        
        
def visualization_tree(interest):
    """a function that visualize trees

    Args:
        interest (string): species of interest 
    """
    #%matplotlib inline

    tree = Phylo.read("Species_Phylogenetic_tree.txt", "newick")
    #print(tree)
    Phylo.draw_ascii(tree)
    tree.rooted = True

   # tree = tree.as_phyloxml()
    #tree = Phylogeny.from_tree(tree)
    #tree.root.color = "blue"           
    interest = str(interest)
    mrca = tree.common_ancestor({"name": interest}) #write the species under interest
    mrca.color = "salmon" #color species under interest


    #Phylo.draw(tree) #draw tree after colors   
    
def get_colors(seqs):
    """make colors for bases in sequence to build the phylogenetic tree"""
    text = [i for s in list(seqs) for i in s]
    clrs =  { "A" : "#1e67b6",
    "C" : "#00a391",
    "D" : "#ea42fc",
    "E" : "#109c4b",
    "F" : "#fed700",
    "G" : "#8d4712",
    "H" : "#ff8e00",
    "I" : "#d82626",
    "K" : "#109c4b",
    "L" : "#d82626",
    "M" : "#d82626",
    "N" : "#ea42fc",
    "P" : "#ffa9e3",
    "Q" : "#109c4b",
    "R" : "#109c4b",
    "S" : "#1e67b6",
    "T" : "#1e67b6",
    "V" : "#d82626",
    "W" : "#fed700",
    "Y" : "#fed700", "-" : "black"}
    colors = [clrs[i] for i in text]
    return colors

def view_alignment(aln, fontsize="9pt", plot_width=800):
    """Bokeh sequence alignment view"""

    #make sequence and id lists from the aln object
    seqs = [rec.seq for rec in (aln)]
    ids = [rec.id for rec in aln]    
    text = [i for s in list(seqs) for i in s]
    colors = get_colors(seqs)    
    N = len(seqs[0])
    S = len(seqs)    
    width = .4

    x = np.arange(1,N+1)
    y = np.arange(0,S,1)
    #creates a 2D grid of coords from the 1D arrays
    xx, yy = np.meshgrid(x, y)
    #flattens the arrays
    gx = xx.ravel()
    gy = yy.flatten()
    #use recty for rect coords with an offset
    recty = gy+.5
    h= 1/S
    #now we can create the ColumnDataSource with all the arrays
    source = ColumnDataSource(dict(x=gx, y=gy, recty=recty, text=text, colors=colors))
    plot_height = len(seqs)*15+50
    x_range = Range1d(0,N+1, bounds='auto')
    if N>100:
        viewlen=100
    else:
        viewlen=N
    #view_range is for the close up view
    view_range = (0,viewlen)
    tools="xpan, xwheel_zoom, reset, save"

    #entire sequence view (no text, with zoom)
    p = figure(title=None, plot_width= plot_width, plot_height=50,
               x_range=x_range, y_range=(0,S), tools=tools,
               min_border=0, toolbar_location='below')
    rects = Rect(x="x", y="recty",  width=1, height=1, fill_color="colors",
                 line_color=None, fill_alpha=0.6)
    p.add_glyph(source, rects)
    p.yaxis.visible = False
    p.grid.visible = False  

    #sequence text view with ability to scroll along x axis
    p1 = figure(title=None, plot_width=plot_width, plot_height=plot_height,
                x_range=view_range, y_range=ids, tools="xpan,reset",
                min_border=0, toolbar_location='below')#, lod_factor=1)          
    glyph = Text(x="x", y="y", text="text", text_align='center',text_color="black",
                text_font="monospace",text_font_size=fontsize)
    rects = Rect(x="x", y="recty",  width=1, height=1, fill_color="colors",
                line_color=None, fill_alpha=0.4)
    p1.add_glyph(source, glyph)
    p1.add_glyph(source, rects)

    p1.grid.visible = False
    p1.xaxis.major_label_text_font_style = "bold"
    p1.yaxis.minor_tick_line_width = 0
    p1.yaxis.major_tick_line_width = 0

    p = gridplot([[p],[p1]], toolbar_location='below')
    show(p)
    return p

def codeml_creating_file():
    """
        function that creates configuration files for codeml
    """
    
    
    c078 = """          seqfile = Reverse_Translation_Seq.txt-gb1.fst * fasta file
         treefile = Species_Phylogenetic_tree_newick_nodistances.nwk * 
          outfile = codeml078_mlc.txt

            noisy = 9   * 0,1,2,3,9: how much rubbish on the screen
          verbose = 1   * 1: detailed output, 0: concise output
          runmode = 0   * 0: user tree;  1: semi-automatic;  2: automatic
                        * 3: StepwiseAddition; (4,5):PerturbationNNI 

          seqtype = 1   * 1:codons; 2:AAs; 3:codons-->AAs
        CodonFreq = 2   * 0:1/61 each, 1:F1X4, 2:F3X4, 3:codon table
            clock = 0   * 0: no clock, unrooted tree, 1: clock, rooted tree
            model = 0   * 0 - site models 2 - branch and branch-site models
                        * models for codons:
                            * 0:one, 1:b, 2:2 or more dN/dS ratios for branches

          NSsites = 0 7 8   * dN/dS among sites. 0:no variation, 1:neutral, 2:positive
            icode = 0   * 0:standard genetic code; 1:mammalian mt; 2-10:see below

        fix_kappa = 0   * 1: kappa fixed, 0: kappa to be estimated
            kappa = 2   * initial or fixed kappa
        fix_omega = 0   * 1: omega or omega_1 fixed, 0: estimate 
            omega = 2   * initial or fixed omega, for codons or codon-transltd AAs

        fix_alpha = 1   * 0: estimate gamma shape parameter; 1: fix it at alpha
            alpha = .0  * initial or fixed alpha, 0:infinity (constant rate)
           Malpha = 0   * different alphas for genes
            ncatG = 4   * # of categories in the dG or AdG models of rates

            getSE = 0   * 0: don't want them, 1: want S.E.s of estimates
     RateAncestor = 0   * (1/0): rates (alpha>0) or ancestral states (alpha=0)
           method = 0   * 0: simultaneous; 1: one branch at a time
      fix_blength = 0  * 0: ignore, -1: random, 1: initial, 2: fixed, 3: proportional
        cleandata = 0  * remove sites with ambiguity data (1:yes, 0:no)?


    * Specifications for duplicating results for the small data set in table 1
    * of Yang (1998 MBE 15:568-573).
    * see the tree file lysozyme.trees for specification of node (branch) labels"""

    c8a = """          seqfile = Reverse_Translation_Seq.txt-gb1.fst * fasta file
         treefile = Species_Phylogenetic_tree_newick_nodistances.nwk * 
          outfile = codeml8a_mlc.txt

            noisy = 9   * 0,1,2,3,9: how much rubbish on the screen
          verbose = 1   * 1: detailed output, 0: concise output
          runmode = 0   * 0: user tree;  1: semi-automatic;  2: automatic
                        * 3: StepwiseAddition; (4,5):PerturbationNNI 

          seqtype = 1   * 1:codons; 2:AAs; 3:codons-->AAs
        CodonFreq = 2   * 0:1/61 each, 1:F1X4, 2:F3X4, 3:codon table
            clock = 0   * 0: no clock, unrooted tree, 1: clock, rooted tree
            model = 0   * 0 - site models 2 - branch and branch-site models
                        * models for codons:
                            * 0:one, 1:b, 2:2 or more dN/dS ratios for branches

          NSsites = 8  * dN/dS among sites. 0:no variation, 1:neutral, 2:positive
            icode = 0   * 0:standard genetic code; 1:mammalian mt; 2-10:see below

        fix_kappa = 0   * 1: kappa fixed, 0: kappa to be estimated
            kappa = 2   * initial or fixed kappa
        fix_omega = 1   * 1: omega or omega_1 fixed, 0: estimate 
            omega = 1   * initial or fixed omega, for codons or codon-transltd AAs

        fix_alpha = 1   * 0: estimate gamma shape parameter; 1: fix it at alpha
            alpha = .0  * initial or fixed alpha, 0:infinity (constant rate)
           Malpha = 0   * different alphas for genes
            ncatG = 4   * # of categories in the dG or AdG models of rates

            getSE = 0   * 0: don't want them, 1: want S.E.s of estimates
     RateAncestor = 0   * (1/0): rates (alpha>0) or ancestral states (alpha=0)
           method = 0   * 0: simultaneous; 1: one branch at a time
      fix_blength = 0  * 0: ignore, -1: random, 1: initial, 2: fixed, 3: proportional
        cleandata = 0  * remove sites with ambiguity data (1:yes, 0:no)?


    * Specifications for duplicating results for the small data set in table 1
    * of Yang (1998 MBE 15:568-573).
    * see the tree file lysozyme.trees for specification of node (branch) labels"""

    c2a = """          seqfile = Reverse_Translation_Seq.txt-gb1.fst * fasta file
         treefile = Species_Phylogenetic_tree_newick_Interst#.nwk * 
          outfile = codeml2a_mlc.txt

            noisy = 9   * 0,1,2,3,9: how much rubbish on the screen
          verbose = 1   * 1: detailed output, 0: concise output
          runmode = 0   * 0: user tree;  1: semi-automatic;  2: automatic
                        * 3: StepwiseAddition; (4,5):PerturbationNNI 

          seqtype = 1   * 1:codons; 2:AAs; 3:codons-->AAs
        CodonFreq = 2   * 0:1/61 each, 1:F1X4, 2:F3X4, 3:codon table
            clock = 0   * 0: no clock, unrooted tree, 1: clock, rooted tree
            model = 2   * 0 - site models 2 - branch and branch-site models
                        * models for codons:
                            * 0:one, 1:b, 2:2 or more dN/dS ratios for branches

          NSsites = 2  * dN/dS among sites. 0:no variation, 1:neutral, 2:positive
            icode = 0   * 0:standard genetic code; 1:mammalian mt; 2-10:see below

        fix_kappa = 0   * 1: kappa fixed, 0: kappa to be estimated
            kappa = 2   * initial or fixed kappa
        fix_omega = 0   * 1: omega or omega_1 fixed, 0: estimate 
            omega = 2   * initial or fixed omega, for codons or codon-transltd AAs

        fix_alpha = 1   * 0: estimate gamma shape parameter; 1: fix it at alpha
            alpha = .0  * initial or fixed alpha, 0:infinity (constant rate)
           Malpha = 0   * different alphas for genes
            ncatG = 4   * # of categories in the dG or AdG models of rates

            getSE = 0   * 0: don't want them, 1: want S.E.s of estimates
     RateAncestor = 0   * (1/0): rates (alpha>0) or ancestral states (alpha=0)
           method = 0   * 0: simultaneous; 1: one branch at a time
      fix_blength = 0  * 0: ignore, -1: random, 1: initial, 2: fixed, 3: proportional
        cleandata = 0  * remove sites with ambiguity data (1:yes, 0:no)?


    * Specifications for duplicating results for the small data set in table 1
    * of Yang (1998 MBE 15:568-573).
    * see the tree file lysozyme.trees for specification of node (branch) labels"""

    c2 = """          seqfile = Reverse_Translation_Seq.txt-gb1.fst * fasta file
         treefile = Species_Phylogenetic_tree_newick_Interst#.nwk * 
          outfile = codeml2_mlc.txt

            noisy = 9   * 0,1,2,3,9: how much rubbish on the screen
          verbose = 1   * 1: detailed output, 0: concise output
          runmode = 0   * 0: user tree;  1: semi-automatic;  2: automatic
                        * 3: StepwiseAddition; (4,5):PerturbationNNI 

          seqtype = 1   * 1:codons; 2:AAs; 3:codons-->AAs
        CodonFreq = 2   * 0:1/61 each, 1:F1X4, 2:F3X4, 3:codon table
            clock = 0   * 0: no clock, unrooted tree, 1: clock, rooted tree
            model = 2  * 0 - site models 2 - branch and branch-site models
                        * models for codons:
                            * 0:one, 1:b, 2:2 or more dN/dS ratios for branches

          NSsites = 2   * dN/dS among sites. 0:no variation, 1:neutral, 2:positive
            icode = 0   * 0:standard genetic code; 1:mammalian mt; 2-10:see below

        fix_kappa = 0   * 1: kappa fixed, 0: kappa to be estimated
            kappa = 2   * initial or fixed kappa
        fix_omega = 1   * 1: omega or omega_1 fixed, 0: estimate 
            omega = 1   * initial or fixed omega, for codons or codon-transltd AAs

        fix_alpha = 1   * 0: estimate gamma shape parameter; 1: fix it at alpha
            alpha = .0  * initial or fixed alpha, 0:infinity (constant rate)
           Malpha = 0   * different alphas for genes
            ncatG = 4   * # of categories in the dG or AdG models of rates

            getSE = 0   * 0: don't want them, 1: want S.E.s of estimates
     RateAncestor = 0   * (1/0): rates (alpha>0) or ancestral states (alpha=0)
           method = 0   * 0: simultaneous; 1: one branch at a time
      fix_blength = 0  * 0: ignore, -1: random, 1: initial, 2: fixed, 3: proportional
        cleandata = 0  * remove sites with ambiguity data (1:yes, 0:no)?


    * Specifications for duplicating results for the small data set in table 1
    * of Yang (1998 MBE 15:568-573).
    * see the tree file lysozyme.trees for specification of node (branch) labels"""
    codeml078 = open("codeml078.ctl" , "w")
    codeml078.write(c078)
    codeml8a = open("codeml8a.ctl" , "w")
    codeml8a.write(c8a)
    codeml2a = open("codeml2a.ctl","w")
    codeml2a.write(c2a)
    codeml2 = open("codeml2.ctl", "w")
    codeml2.write(c2)
    
    
def number_of_fetched_species():
    path = os.getcwd()
    list_files = glob.glob("*.gene")

    counter = [["Name", "Number of Species"]]
    x = open("output.txt",'w')
    for i in list_files:
        reading = open(path + '/' + i + '/' + 'CodingSequences.fasta', 'r')
        reading2 = reading.read()
        counter.append([i, reading2.count('>')])
    df = pd.DataFrame(counter)
    df.to_csv("fetched_species.csv")




def codeml_output(state, protein):
    """
        Function creates a spreadsheet for the p-values

    Args:
        state (int 0 or 1): state shows whether model2 and model 2a is required
        protein (string):  the name of the protein
    """
    def parser(file):
        lis = []
        lines = file.readlines()
        for i in lines:
            if "lnL" in i:
                start = i.find("):")
                end = i.find("      ")
                lis.append(float(i[start+3:end].strip()))
        return lis

    reader078 = open("codeml078/codeml078_mlc.txt","r")
    models078 = parser(reader078)

    reader8a = open("codeml8a/codeml8a_mlc.txt","r")
    model8a = parser(reader8a)

    model2a = [""]
    model2 = [""]
    lrt22a = ''
    
    if state == 1:
        reader2a = open("codeml2a/codeml2a_mlc.txt","r")
        model2a = parser(reader2a)
        
        reader2 = open("codeml2/codeml2_mlc.txt","r")
        model2 = parser(reader2)
        
        lrt22a = 2*(model2a[0] - model2[0])

    lrt78 = 2*(models078[2] - models078[1])
    lrt88a = 2*(models078[2] - model8a[0])

    chi78 =  1 - chi2.cdf(lrt78, 2)
    chi88a =  1 - chi2.cdf(lrt88a, 1)
    chi22a = 1 - chi2.cdf(lrt22a, 1) if state == 1 else ''

    with open("Gene_Output.csv", "w") as newfile:
        wr = csv.writer(newfile)
        wr.writerow(["Name","Model0", "Model7", "Model8","Model8a", "Model2a", "Model2", "LRT(M7_vs_M8)", "LRT(M8a_vs_M8)", "LRT(M2a_vs_M2)", "p-v7vs8", "p-v8avs8", "p-v2avs2"])
        wr.writerow([protein, models078[0], models078[1], models078[2], model8a[0], model2a[0], model2[0],lrt78, lrt88a, lrt22a, chi78, chi88a, chi22a])
        
codeml_creating_file()
